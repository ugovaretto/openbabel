<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Stereochemistry</title>
<link href="/site.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="search/search.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<!--#include file="header.html" -->
<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.shtml"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.shtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.shtml"><span>Modules</span></a></li>
      <li><a href="namespaces.shtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.shtml"><span>Classes</span></a></li>
      <li><a href="files.shtml"><span>Files</span></a></li>
      <li><a href="examples.shtml"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Stereochemistry</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml">OBCisTransStereo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling and storing cis/trans stereochemistry.  <a href="classOpenBabel_1_1OBCisTransStereo.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBSquarePlanarStereo.shtml">OBSquarePlanarStereo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling and storing square planar stereochemistry.  <a href="classOpenBabel_1_1OBSquarePlanarStereo.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenBabel_1_1OBStereo.shtml">OBStereo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for enums &amp; Ref/Refs related functions.  <a href="structOpenBabel_1_1OBStereo.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenBabel_1_1OBStereoUnit.shtml">OBStereoUnit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing a single stereogenic unit.  <a href="structOpenBabel_1_1OBStereoUnit.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBStereoBase.shtml">OBStereoBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all stereochemistry classes.  <a href="classOpenBabel_1_1OBStereoBase.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBStereoFacade.shtml">OBStereoFacade</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Facade to simplify retrieval of <a class="el" href="classOpenBabel_1_1OBStereoBase.shtml" title="Base class for all stereochemistry classes.">OBStereoBase</a> derived objects.  <a href="classOpenBabel_1_1OBStereoFacade.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml">OBTetrahedralStereo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling and storing tetrahedral atom stereochemistry.  <a href="classOpenBabel_1_1OBTetrahedralStereo.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenBabel_1_1OBTetraNonPlanarStereo.shtml">OBTetraNonPlanarStereo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for handling and storing non-planar stereochemistry with 4 reference atom ids.  <a href="classOpenBabel_1_1OBTetraNonPlanarStereo.shtml#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; OBStereoUnit &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga042299211c7a52f5aee1975d32820af7">OBStereoUnitSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; OBStereoUnitSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga75c7c66edf2555b974417a77968ebb57">OBStereoUnitSetOfSets</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gadf8c733643a40f5135c2e0d8a32764c4">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml">OpenBabel::OBCisTransStereo</a> &amp;ct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gaa6a386afa954e168b8c1c5b15c2d6f27">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structOpenBabel_1_1OBCisTransStereo_1_1Config.shtml">OpenBabel::OBCisTransStereo::Config</a> &amp;cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga9a6442f8a6cda1d0eb673a0199c9226d">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classOpenBabel_1_1OBSquarePlanarStereo.shtml">OpenBabel::OBSquarePlanarStereo</a> &amp;ct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gaca674872623ccf5104d49756ed4f8c22">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structOpenBabel_1_1OBSquarePlanarStereo_1_1Config.shtml">OpenBabel::OBSquarePlanarStereo::Config</a> &amp;cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga30c6cc4c63f918bad5ed504e0e53edc6">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml">OpenBabel::OBTetrahedralStereo</a> &amp;ts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gaa6dbf885c726a181852e742bb0b9a65d">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structOpenBabel_1_1OBTetrahedralStereo_1_1Config.shtml">OpenBabel::OBTetrahedralStereo::Config</a> &amp;cfg)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
High level functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gae7aedffc6994cf26d16524389c56bdac">PerceiveStereo</a> (OBMol *mol, bool force=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D</a> (OBMol *mol, std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; *updown=NULL, bool force=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> (OBMol *mol, bool force=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D</a> (OBMol *mol)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Low level functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; OBTetrahedralStereo * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga35e07645a245db366b115f0dc20542fd">TetrahedralFrom3D</a> (OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; OBTetrahedralStereo * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gab85c5ef4c9416ee7af02b21658fe9de2">TetrahedralFrom2D</a> (OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector<br class="typebreak"/>
&lt; OBTetrahedralStereo * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gac3049b86debe9059b851825b29b1557c">TetrahedralFrom0D</a> (OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; OBCisTransStereo * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga7e1ba3a4ac33b0c6404b0d960cc53d00">CisTransFrom3D</a> (OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; OBCisTransStereo * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga98528c3002ed718695ccfaf031ca3f04">CisTransFrom2D</a> (OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, const std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; *updown=NULL, bool addToMol=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga182a53150e1793ac1ec14958afb05f17">TetStereoToWedgeHash</a> (OBMol &amp;mol, std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; &amp;updown, std::map&lt; OBBond *, OBStereo::Ref &gt; &amp;from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::set&lt; OBBond * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga63e739a42d88ac64ed77c07d73866a45">GetUnspecifiedCisTrans</a> (OBMol &amp;mol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga9b44683d071146220a97390283944f70">StereoRefToImplicit</a> (OBMol &amp;mol, OBStereo::Ref atomId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; OBCisTransStereo * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gac74fff254a639ede4d92a59fa44318a6">CisTransFrom0D</a> (OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Stereogenic unit identification</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OBStereoUnitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> (OBMol *mol, const std::vector&lt; unsigned int &gt; &amp;symClasses)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OBStereoUnitSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stereo.shtml#ga0f62e73467d2059ad28d544633634862">FindStereogenicUnits</a> (OBMol *mol, const std::vector&lt; unsigned int &gt; &amp;symClasses, const Automorphisms &amp;automorphisms)</td></tr>
</table>
<div class="textblock"><h2><a class="anchor" id="overview"></a>
Overview of classes</h2>
<p>There are many molecules which contain stereogenic elements. However, certain cases (i.e. tetrahedral, cis/trans) are more common than others (i.e. allene, biphenyl, octrahedral, ...). For the common stereogenic units, classes are provided. The inheritance of these classes resembles the way they are split into groups.</p>
<ul>
<li><a class="el" href="classOpenBabel_1_1OBStereoBase.shtml" title="Base class for all stereochemistry classes.">OBStereoBase</a><ul>
<li><a class="el" href="classOpenBabel_1_1OBTetraNonPlanarStereo.shtml" title="Base class for handling and storing non-planar stereochemistry with 4 reference atom ids...">OBTetraNonPlanarStereo</a><ul>
<li><a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a></li>
<li>OBExtendedTetrahedralStereo</li>
</ul>
</li>
<li><a class="el" href="classOpenBabel_1_1OBTetraPlanarStereo.shtml" title="Base class for handling and storing planar stereochemistry with 4 reference atoms.">OBTetraPlanarStereo</a><ul>
<li><a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a></li>
<li>OBExtendedCisTransStereo</li>
<li><a class="el" href="classOpenBabel_1_1OBSquarePlanarStereo.shtml" title="Class for handling and storing square planar stereochemistry.">OBSquarePlanarStereo</a></li>
</ul>
</li>
<li>OBAxialStereo<ul>
<li>OBTrigonalBipyrimidalStereo</li>
<li>OBOctahedralStereo</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="image">
<img src="tetranonplanar.png" alt="tetranonplanar.png"/>
</div>
 <div class="image">
<img src="tetraplanar.png" alt="tetraplanar.png"/>
</div>
<p>All specific classes (i.e. <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a>, ...) have embedded Config structs which define the actual stereochemistry. All these Config structs use <a class="el" href="structOpenBabel_1_1OBStereo.shtml#aff913cc7d694153b33e2b3ac168a6350">OBStereo::Ref</a> values to reference or uniquely identify atoms. Make sure to read about <a class="el" href="structOpenBabel_1_1OBStereo.shtml#aff913cc7d694153b33e2b3ac168a6350">OBStereo::Ref</a> and the related functions (in <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a>). <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> is also a placeholder for various enums with predefined values for parameters etc. These enums are used throughout the different stereo classes but having these enums in a single location makes it easier to remember. When working with stereo classes, you normally don't need to use any of the parent classes directly. Only <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> and the specific class are needed.</p>
<h2><a class="anchor" id="usage"></a>
Basic usage</h2>
<p>The <a class="el" href="classOpenBabel_1_1OBStereoFacade.shtml" title="Facade to simplify retrieval of OBStereoBase derived objects.">OBStereoFacade</a> hides the complexity of working with stereochemistry. When using openbabel as a library, this is by far the easiest way to access stereochemistry information. The header for the specific <a class="el" href="structOpenBabel_1_1OBStereo.shtml#a1d1cfd8ffb84e947f82999c682b666a7">OBStereo::Type</a> type is all you need to include. These are:</p>
<ul>
<li><em><a class="el" href="tetrahedral_8h.shtml" title="Handle general non-planar tetrahedral stereochemistry.">openbabel/stereo/tetrahedral.h</a></em> </li>
<li><em><a class="el" href="cistrans_8h.shtml" title="Store and convert cis/trans double-bond stereochemistry.">openbabel/stereo/cistrans.h</a></em> </li>
<li><em><a class="el" href="squareplanar_8h.shtml" title="Store and convert square-planar stereochemistry.">openbabel/stereo/squareplanar.h</a></em> </li>
</ul>
<p>All these headers also include <em><a class="el" href="stereo_8h.shtml" title="Process molecular stereochemistry information.">openbabel/stereo/stereo.h</a></em> providing declarations for <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> &amp; <a class="el" href="classOpenBabel_1_1OBStereoFacade.shtml" title="Facade to simplify retrieval of OBStereoBase derived objects.">OBStereoFacade</a>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">     #include &lt;iostream&gt;</span>
<span class="preprocessor">     #include &lt;<a class="code" href="mol_8h.shtml" title="Handle molecules. Declarations of OBMol, OBAtom, OBBond, OBResidue. (the main header for Open Babel)...">openbabel/mol.h</a>&gt;</span>
<span class="preprocessor">     #include &lt;<a class="code" href="obconversion_8h.shtml" title="Handle file conversions. Declaration of OBFormat, OBConversion.">openbabel/obconversion.h</a>&gt;</span>

<span class="preprocessor">     #include &lt;<a class="code" href="tetrahedral_8h.shtml" title="Handle general non-planar tetrahedral stereochemistry.">openbabel/stereo/tetrahedral.h</a>&gt;</span>

     <span class="keyword">using namespace </span>OpenBabel;

     <span class="keywordtype">int</span> main()
     {
       <a class="code" href="classOpenBabel_1_1OBMol.shtml" title="Molecule Class.">OBMol</a> mol;
       <a class="code" href="classOpenBabel_1_1OBConversion.shtml" title="Class to convert from one format to another.">OBConversion</a> conv;
       conv.<a class="code" href="classOpenBabel_1_1OBConversion.shtml#a58e81dd6fcba14828db82a9782e5cff9" title="Sets the input format from an id e.g. CML.">SetInFormat</a>(<span class="stringliteral">&quot;smi&quot;</span>);
       conv.<a class="code" href="classOpenBabel_1_1OBConversion.shtml#a93558e9c89cda2e1a4f9fb2cadc5c8d1" title="Reads an object of a class derived from OBBase into pOb from the supplied string.">ReadString</a>(&amp;mol, <span class="stringliteral">&quot;C[C@H](Cl)Br&quot;</span>);

       <a class="code" href="classOpenBabel_1_1OBStereoFacade.shtml" title="Facade to simplify retrieval of OBStereoBase derived objects.">OBStereoFacade</a> facade(&amp;mol);

       <a class="code" href="obiter_8h.shtml#afb051cb17b46d381998c24fc41db2a79">FOR_ATOMS_OF_MOL</a>(atom, mol) {
         <span class="keywordflow">if</span> (facade.HasTetrahedralStereo(atom-&gt;GetId()))
           std::cout &lt;&lt; facade.GetTetrahedralStereo(atom-&gt;GetId()) &lt;&lt; std::endl;
       }
     }
</pre></div><p>All specific stereo classes and their embedded Config struct have an operator&lt;&lt; function which allows them to be used with std::ostream objects (e.g. std::cout, std::err, ...). These functions are often useful when debugging code.</p>
<h2><a class="anchor" id="details"></a>
Details on implementation</h2>
<p>The detection of stereogenic units start with symmetry analysis. However, a complete symmetry analysis also needs to take stereochemistry into account. In practice, this means stereochemistry will be found iteratively. At each iteration, the current atom symmetry classes are used to identify stereogenic units. The details about how the symmetry classes are used depends on the type (<a class="el" href="structOpenBabel_1_1OBStereo.shtml#a1d1cfd8ffb84e947f82999c682b666a7">OBStereo::Type</a>) of stereogenic unit. For tetrahedral centers, having 3 heavy atom neighbors with different symmetry classes or 4 neighbors with different symmetry classes means the atom is chiral. See <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits()</a> for details.</p>
<p>After identifying the stereogenic units, Config structs with all the information on the spacial arrangement of the groups still have to be created. This involves interpreting various ways to represent stereochemisrty:</p>
<ul>
<li>3D coordinates: <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a></li>
<li>2D coordinates: <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D()</a></li>
<li>0D coordinates: <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a></li>
</ul>
<p>Both <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a> and <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D()</a> delete all existing stereochemistry objects before adding new ones. For molecules with 3D coordinates, it is evident that all information is specified by the coordinates itself. However, if a file format uses stereo parity flags, Config structs must be constructed using lower level functions and <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a> should not be called. In these cases information could be lost by calling <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a> after reading the file (the stereo flag might have indicated the stereochemistry was unspecified or the flag might not match the coordinates). In the case of 2D molecules, the coordinates together with bond properties (<a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326ae44c0278588a18b472943c7f72857c03" title="A dashed &quot;hash&quot; bond in 2D representations -- i.e., &quot;down&quot; from the 2D plane.">OBBond::Hash</a>, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a721d5e522bcc0b0defce43b967d34091" title="A solid black wedge in 2D representations -- i.e., &quot;up&quot; from the 2D plane.">OBBond::Wedge</a>, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a96d5e3fcebcf162bf697dcf08f6e2063" title="The bond is either wedge or hash, this is a seperate flag!">OBBond::WedgeOrHash</a> and <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a1a4533d507bb26970b15bb7ba5ce6b3d" title="Indicates the 2D/3D coordinates are accidently cis/trans.">OBBond::CisOrTrans</a>) define the stereochemistry. Again, lower level functions can be used when stereo flags need to be used.</p>
<p><a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> works slightly different than 3D/2D. Here, deleting the stereochemistry would always result in lost information. Instead <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> only adds new objects for stereogenic units which were previously not found. For example, a smiles is read which has two tetrahedral centers. Only one has stereochemistry specified using a '@' character. <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> will detect the second tetrahedral atom and add an <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> object to the molecule. The Config::specified flag for the newly added structs is always set to false.</p>
<p>Assuming the format code has correctly set the molecule dimensions (OBMol::GetDimesions), <a class="el" href="group__stereo.shtml#gae7aedffc6994cf26d16524389c56bdac">PerceiveStereo()</a> will automatically select the correct function to call. When <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a>, <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D()</a> or <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> are not used, make sure to always set <a class="el" href="classOpenBabel_1_1OBMol.shtml#a39df67d7e225b9dd721b9b8c7df809ce" title="Has atom chirality been assigned?">OBMol::HasChiralityPerceived()</a> before returning from the format's ReadMolecule().</p>
<h2><a class="anchor" id="formats"></a>
Guidelines for formats</h2>
<h3><a class="anchor" id="input"></a>
Reading files</h3>
<ul>
<li>Read the section above</li>
<li>The MDL format (mdlformat.cpp) is a good example for 2D/3D formats with or without parity flags.</li>
<li>The SMILES format (smilesformat.cpp) is a good example for 0D formats.</li>
</ul>
<h3><a class="anchor" id="output"></a>
Writing files</h3>
<p>For many file formats no additional code is needed. For example, if a 3D format doesn't require stereo parity flags, writing the coordinates is enough. For 2D file formats it will often suffice to write the coordinates and bond properties. If parity flags are needed, the <a class="el" href="classOpenBabel_1_1OBStereoFacade.shtml" title="Facade to simplify retrieval of OBStereoBase derived objects.">OBStereoFacade</a> class can be used to retreive the objects for all types of stereochemistry supported by the file format.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga042299211c7a52f5aee1975d32820af7"></a><!-- doxytag: member="OpenBabel::OBStereoUnitSet" ref="ga042299211c7a52f5aee1975d32820af7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;OBStereoUnit&gt; OBStereoUnitSet</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A single set of <a class="el" href="structOpenBabel_1_1OBStereoUnit.shtml" title="Struct representing a single stereogenic unit.">OBStereoUnit</a> objects. </p>
<p>This type can be used to represent all stereogenic units in a molecule and is used as return type of FinStereogenicUnits(). This set is also the input for many functions requiring this information (e.g. StereoFrom2D, ...). </p>

</div>
</div>
<a class="anchor" id="ga75c7c66edf2555b974417a77968ebb57"></a><!-- doxytag: member="OpenBabel::OBStereoUnitSetOfSets" ref="ga75c7c66edf2555b974417a77968ebb57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;OBStereoUnitSet&gt; OBStereoUnitSetOfSets</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A set of sets of <a class="el" href="structOpenBabel_1_1OBStereoUnit.shtml" title="Struct representing a single stereogenic unit.">OBStereoUnit</a> objects. </p>
<p>This type is used for cases where there is some relationship between individual <a class="el" href="structOpenBabel_1_1OBStereoUnit.shtml" title="Struct representing a single stereogenic unit.">OBStereoUnit</a> objects. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadf8c733643a40f5135c2e0d8a32764c4"></a><!-- doxytag: member="std::operator&lt;&lt;" ref="gadf8c733643a40f5135c2e0d8a32764c4" args="(ostream &amp;out, const OpenBabel::OBCisTransStereo &amp;ct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; std::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml">OpenBabel::OBCisTransStereo</a> &amp;&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> OBCisTransStereo::Config cfg;
 cfg.begin = 0;
 cfg.end = 1;
 cfg.refs = OBStereo::MakeRefs(2, 3, 4, 5);
 cfg.shape = OBStereo::ShapeU;

 OBCisTransStereo ct(mol);
 ct.SetConfig(cfg)

 cout &lt;&lt; <span class="stringliteral">&quot;ct = &quot;</span> &lt;&lt; ct &lt;&lt; endl;

 <span class="comment">// output</span>
 OBCisTransStereo(begin = 0, end = 1, refs = 2 3 4 5, shape = <a class="code" href="namespaceOpenBabel_1_1OBResidueIndex.shtml#abc5c98fcc1211af2b80116dd6e0a035dac461e84f27bbb236874e1011cd66031f">U</a>)
</pre></div> 
</div>
</div>
<a class="anchor" id="gaa6a386afa954e168b8c1c5b15c2d6f27"></a><!-- doxytag: member="std::operator&lt;&lt;" ref="gaa6a386afa954e168b8c1c5b15c2d6f27" args="(ostream &amp;out, const OpenBabel::OBCisTransStereo::Config &amp;cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; std::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOpenBabel_1_1OBCisTransStereo_1_1Config.shtml">OpenBabel::OBCisTransStereo::Config</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> OBCisTransStereo::Config cfg;
 cfg.begin = 0;
 cfg.end = 1;
 cfg.refs = OBStereo::MakeRefs(2, 3, 4, 5);
 cfg.shape = OBStereo::ShapeU;

 cout &lt;&lt; <span class="stringliteral">&quot;cfg = &quot;</span> &lt;&lt; cfg &lt;&lt; endl;

 <span class="comment">// output</span>
 OBCisTransStereo::Config(begin = 0, end = 1, refs = 2 3 4 5, shape = <a class="code" href="namespaceOpenBabel_1_1OBResidueIndex.shtml#abc5c98fcc1211af2b80116dd6e0a035dac461e84f27bbb236874e1011cd66031f">U</a>)
</pre></div> 
</div>
</div>
<a class="anchor" id="ga9a6442f8a6cda1d0eb673a0199c9226d"></a><!-- doxytag: member="std::operator&lt;&lt;" ref="ga9a6442f8a6cda1d0eb673a0199c9226d" args="(ostream &amp;out, const OpenBabel::OBSquarePlanarStereo &amp;ct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; std::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBSquarePlanarStereo.shtml">OpenBabel::OBSquarePlanarStereo</a> &amp;&#160;</td>
          <td class="paramname"><em>ct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> OBSquarePlanarStereo::Config cfg;
 cfg.center = 0;
 cfg.refs = OBStereo::MakeRefs(1, 2, 3, 4);
 cfg.shape = OBStereo::ShapeU;

 OBSquarePlanarStereo ct(mol);
 ct.SetConfig(cfg)

 cout &lt;&lt; <span class="stringliteral">&quot;ct = &quot;</span> &lt;&lt; ct &lt;&lt; endl;

 <span class="comment">// output</span>
 OBSquarePlanarStereo(center = 0, refs = 1 2 3 4, shape = <a class="code" href="namespaceOpenBabel_1_1OBResidueIndex.shtml#abc5c98fcc1211af2b80116dd6e0a035dac461e84f27bbb236874e1011cd66031f">U</a>)
</pre></div> 
</div>
</div>
<a class="anchor" id="gaca674872623ccf5104d49756ed4f8c22"></a><!-- doxytag: member="std::operator&lt;&lt;" ref="gaca674872623ccf5104d49756ed4f8c22" args="(ostream &amp;out, const OpenBabel::OBSquarePlanarStereo::Config &amp;cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; std::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOpenBabel_1_1OBSquarePlanarStereo_1_1Config.shtml">OpenBabel::OBSquarePlanarStereo::Config</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> OBSquarePlanarStereo::Config cfg;
 cfg.center = 0;
 cfg.refs = OBStereo::MakeRefs(1, 2, 3, 4);
 cfg.shape = OBStereo::ShapeU;

 cout &lt;&lt; <span class="stringliteral">&quot;cfg = &quot;</span> &lt;&lt; cfg &lt;&lt; endl;

 <span class="comment">// output</span>
 OBSquarePlanarStereo::Config(center = 0, refs = 1 2 3 4, shape = <a class="code" href="namespaceOpenBabel_1_1OBResidueIndex.shtml#abc5c98fcc1211af2b80116dd6e0a035dac461e84f27bbb236874e1011cd66031f">U</a>)
</pre></div> 
</div>
</div>
<a class="anchor" id="gae7aedffc6994cf26d16524389c56bdac"></a><!-- doxytag: member="OpenBabel::PerceiveStereo" ref="gae7aedffc6994cf26d16524389c56bdac" args="(OBMol *mol, bool force=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::PerceiveStereo </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert 0D/2D/3D coordinates to <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> objects. The right function will be selected based on the molecule's dimensionality (i.e. <a class="el" href="classOpenBabel_1_1OBMol.shtml#ae66fbb23621ae4f9e7937540d5072869">OBMol::GetDimension()</a>).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D</a> <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga305c9600a3a336da16683baa395e20f4"></a><!-- doxytag: member="OpenBabel::StereoFrom2D" ref="ga305c9600a3a336da16683baa395e20f4" args="(OBMol *mol, std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; *updown=NULL, bool force=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::StereoFrom2D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; *&#160;</td>
          <td class="paramname"><em>updown</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert the 2D depiction of molecule <code>mol</code> to <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> objects. This function makes use of the lower level functions <a class="el" href="group__stereo.shtml#gab85c5ef4c9416ee7af02b21658fe9de2">TetrahedralFrom2D()</a>, <a class="el" href="group__stereo.shtml#ga98528c3002ed718695ccfaf031ca3f04">CisTransFrom2D()</a>, SquarePlanarFrom2D(), ...</p>
<p>First, symmetry analysis taking stereochemistry into account is performed iteratively (see <a class="el" href="classOpenBabel_1_1OBGraphSym.shtml" title="Handle and perceive graph symmtery for canonical numbering .">OBGraphSym</a>). Next the 2D coordinates, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a721d5e522bcc0b0defce43b967d34091" title="A solid black wedge in 2D representations -- i.e., &quot;up&quot; from the 2D plane.">OBBond::Wedge</a>, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326ae44c0278588a18b472943c7f72857c03" title="A dashed &quot;hash&quot; bond in 2D representations -- i.e., &quot;down&quot; from the 2D plane.">OBBond::Hash</a>, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a96d5e3fcebcf162bf697dcf08f6e2063" title="The bond is either wedge or hash, this is a seperate flag!">OBBond::WedgeOrHash</a> and <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a1a4533d507bb26970b15bb7ba5ce6b3d" title="Indicates the 2D/3D coordinates are accidently cis/trans.">OBBond::CisOrTrans</a> are used to construct <a class="el" href="classOpenBabel_1_1OBStereoBase.shtml" title="Base class for all stereochemistry classes.">OBStereoBase</a> derived objects to store the stereochemistry. These objects will be added to <code>mol</code>.</p>
<p>Unless perception is forced, this function does nothing if stereochemistry has already been perceived (i.e. <a class="el" href="classOpenBabel_1_1OBMol.shtml#a39df67d7e225b9dd721b9b8c7df809ce" title="Has atom chirality been assigned?">OBMol::HasChiralityPerceived()</a>). Before doing the actual perception, any data of the <a class="el" href="namespaceOpenBabel_1_1OBGenericDataType.shtml#a06fc87d81c62e9abb8790b6e5713c55ba3f9974bdbccde7c26064d7ec21d570ef" title="Stereochemistry data (see OBStereoBase)">OBGenericDataType::StereoData</a> type will be deleted.</p>
<div class="fragment"><pre class="fragment">
     Reference:
     [1] T. Cieplak, J.L. Wisniewski, A New Effective Algorithm for the
     Unambiguous Identification of the Stereochemical Characteristics of
     Compounds During Their Registration in Databases. Molecules 2000, 6,
     915-926, http://www.mdpi.org/molecules/papers/61100915/61100915.htm
     </pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule containing 2D coordinates. </td></tr>
    <tr><td class="paramname">updown</td><td>A map of <a class="el" href="structOpenBabel_1_1OBStereo.shtml#a90087c9021331c97c28e9a8329f41e97">OBStereo::BondDirection</a> for cis/trans bonds </td></tr>
    <tr><td class="paramname">force</td><td>Force to run the perception even if the results are cached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D</a> <a class="el" href="group__stereo.shtml#gae7aedffc6994cf26d16524389c56bdac">PerceiveStereo</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gaebcf38fd76c5d76fffbae808b8571f9b"></a><!-- doxytag: member="OpenBabel::StereoFrom3D" ref="gaebcf38fd76c5d76fffbae808b8571f9b" args="(OBMol *mol, bool force=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::StereoFrom3D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert the 3D coordinates of molecule <code>mol</code> to <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> objects. This function makes use of the lower level functions <a class="el" href="group__stereo.shtml#ga35e07645a245db366b115f0dc20542fd">TetrahedralFrom3D()</a>, <a class="el" href="group__stereo.shtml#ga7e1ba3a4ac33b0c6404b0d960cc53d00">CisTransFrom3D()</a>, SquarePlanarFrom3D(), ...</p>
<p>Unless perception is forced, this function does nothing if stereochemistry has already been perceived (i.e. <a class="el" href="classOpenBabel_1_1OBMol.shtml#a39df67d7e225b9dd721b9b8c7df809ce" title="Has atom chirality been assigned?">OBMol::HasChiralityPerceived()</a>). Before doing the actual perception, any data of the <a class="el" href="namespaceOpenBabel_1_1OBGenericDataType.shtml#a06fc87d81c62e9abb8790b6e5713c55ba3f9974bdbccde7c26064d7ec21d570ef" title="Stereochemistry data (see OBStereoBase)">OBGenericDataType::StereoData</a> type will be deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule containing 3D coordinates. </td></tr>
    <tr><td class="paramname">force</td><td>Force to run the perception even if the results are cached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D</a> <a class="el" href="group__stereo.shtml#gae7aedffc6994cf26d16524389c56bdac">PerceiveStereo</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga419e494a34740f1f8003acabfa30a95b"></a><!-- doxytag: member="OpenBabel::StereoFrom0D" ref="ga419e494a34740f1f8003acabfa30a95b" args="(OBMol *mol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::StereoFrom0D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add missing <a class="el" href="structOpenBabel_1_1OBStereo.shtml" title="Placeholder for enums &amp; Ref/Refs related functions.">OBStereo</a> objects. Unlike <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a> and <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D()</a>, this method only adds objects for previously unidentified objects since we don't want to loose any information. The Config::specified flag for the newly added structs is always set to false.</p>
<p>For example, a smiles is read which has two tetrahedral centers. Only one has stereochemisrty specified using a '@' character. <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> will detect the second tetrahedral atom and add an <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> object to the molecule.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D</a> <a class="el" href="group__stereo.shtml#gae7aedffc6994cf26d16524389c56bdac">PerceiveStereo</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga35e07645a245db366b115f0dc20542fd"></a><!-- doxytag: member="OpenBabel::TetrahedralFrom3D" ref="ga35e07645a245db366b115f0dc20542fd" args="(OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;OBTetrahedralStereo*&gt; OpenBabel::TetrahedralFrom3D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereoUnitSet &amp;&#160;</td>
          <td class="paramname"><em>stereoUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToMol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector with all <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects for the molecule. This function is used by <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a> with the <code>addToMol</code> parameter is set to true.</p>
<p>The algorithm to convert the 3D coordinates to <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> object uses the sign of the volume described by the 4 center atom neighbors. Given 4 points <img class="formulaInl" alt="$a$" src="form_0.png"/>, <img class="formulaInl" alt="$b$" src="form_1.png"/>, <img class="formulaInl" alt="$c$" src="form_2.png"/> and <img class="formulaInl" alt="$d$" src="form_3.png"/>, the signed volume <img class="formulaInl" alt="$S_v$" src="form_4.png"/> is defined as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ S_v = \left| \begin{array}{ccc} x_b - x_a &amp; y_b - y_a &amp; z_b - z_a \\ x_c - x_a &amp; y_c - y_a &amp; z_c - z_a \\ x_d - x_a &amp; y_d - y_a &amp; z_d - z_a \end{array} \right| \]" src="form_5.png"/>
</p>
<p>The sign of <img class="formulaInl" alt="$S_v$" src="form_4.png"/> changes when any of the points cross the plane defined by the other 3 points. To make this less abstract one could say that a change of sign is equal to inverting the tetrahedral stereochemistry.</p>
<p>In case there are only 3 neighbor atoms for the tetrahedral center, the center atom itself is used as 4th point. This only changes the magnitude and not the sign of <img class="formulaInl" alt="$S_v$" src="form_4.png"/> because the center atom is still on the same side of the plane.</p>
<p>This function is also used for symmetry analysis to handle cases where there are two atoms in the same symmetry class that don't have the same stereochemistry. In this situation, the <code>addToMol</code> parameter is set to false and the returned objects will need to be deleted explicitly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">stereoUnits</td><td>The stereogenic units. </td></tr>
    <tr><td class="paramname">addToMol</td><td>If true, the <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects will be added to the molecule using <a class="el" href="classOpenBabel_1_1OBBase.shtml#adb6b0ec89bfea783825b3b466e4dbc00" title="Adds a data object; does nothing if d==NULL.">OBBase::SetData()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>, and <a class="el" href="classOpenBabel_1_1OBBuilder.shtml#a568e42fdfa07962a14761bb9875ee138">OBBuilder::CorrectStereoAtoms()</a>.</p>

</div>
</div>
<a class="anchor" id="gab85c5ef4c9416ee7af02b21658fe9de2"></a><!-- doxytag: member="OpenBabel::TetrahedralFrom2D" ref="gab85c5ef4c9416ee7af02b21658fe9de2" args="(OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;OBTetrahedralStereo*&gt; OpenBabel::TetrahedralFrom2D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereoUnitSet &amp;&#160;</td>
          <td class="paramname"><em>stereoUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToMol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector with all <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects for the molecule. This function is used by <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D()</a> with the <code>addToMol</code> parameter is set to true.</p>
<p>The algorithm to convert the 2D coordinates and bond properties (i.e. <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a721d5e522bcc0b0defce43b967d34091" title="A solid black wedge in 2D representations -- i.e., &quot;up&quot; from the 2D plane.">OBBond::Wedge</a>, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326ae44c0278588a18b472943c7f72857c03" title="A dashed &quot;hash&quot; bond in 2D representations -- i.e., &quot;down&quot; from the 2D plane.">OBBond::Hash</a>, <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a96d5e3fcebcf162bf697dcf08f6e2063" title="The bond is either wedge or hash, this is a seperate flag!">OBBond::WedgeOrHash</a> and <a class="el" href="classOpenBabel_1_1OBBond.shtml#afbdb429fe4a7d37960636a555de77326a1a4533d507bb26970b15bb7ba5ce6b3d" title="Indicates the 2D/3D coordinates are accidently cis/trans.">OBBond::CisOrTrans</a>) uses the sign of a triangle. Given 3 points <img class="formulaInl" alt="$a$" src="form_0.png"/>, <img class="formulaInl" alt="$b$" src="form_1.png"/> and <img class="formulaInl" alt="$c$" src="form_2.png"/>, the sign of the trianle <img class="formulaInl" alt="$S_t$" src="form_6.png"/> is defined as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ S_t = (x_a - x_c) (y_b - y_c) - (y_a - y_c) (x_b - x_c) \]" src="form_7.png"/>
</p>
<p>This is equation 6 from on the referenced web page. The 3 points used to calculate the triangle sign always remain in the same plane (i.e. z = 0). The actual meaning of <img class="formulaInl" alt="$S_t$" src="form_6.png"/> (i.e. assignment of <a class="el" href="structOpenBabel_1_1OBStereo.shtml#ac3e0e8e3a194037cdf6103a95a1c6d31">OBStereo::Winding</a>) depends on the 4th atom. When the atom is in front of the plane, the sign should be changed to have the same absolute meaning for an atom behind the plane and the same triangle. It is important to note that none of the z coordinates is ever changed, the molecule always stays 2D (unlike methods which set a pseudo-z coordinate).</p>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000007">Todo:</a></b></dt><dd>document bond property interpretation!</dd></dl>
<p>This function is also used for symmetry analysis to handle cases where there are two atoms in the same symmetry class that don't have the same stereochemistry. In this situation, the <code>addToMol</code> parameter is set to false and the returned objects will need to be deleted explicitly.</p>
<div class="fragment"><pre class="fragment">
     Reference:
     [1] T. Cieplak, J.L. Wisniewski, A New Effective Algorithm for the
     Unambiguous Identification of the Stereochemical Characteristics of
     Compounds During Their Registration in Databases. Molecules 2000, 6,
     915-926, http://www.mdpi.org/molecules/papers/61100915/61100915.htm
     </pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">stereoUnits</td><td>The stereogenic units. </td></tr>
    <tr><td class="paramname">addToMol</td><td>If true, the <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects will be added to the molecule using <a class="el" href="classOpenBabel_1_1OBBase.shtml#adb6b0ec89bfea783825b3b466e4dbc00" title="Adds a data object; does nothing if d==NULL.">OBBase::SetData()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D</a> <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>.</p>

</div>
</div>
<a class="anchor" id="gac3049b86debe9059b851825b29b1557c"></a><!-- doxytag: member="OpenBabel::TetrahedralFrom0D" ref="gac3049b86debe9059b851825b29b1557c" args="(OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;OBTetrahedralStereo*&gt; OpenBabel::TetrahedralFrom0D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereoUnitSet &amp;&#160;</td>
          <td class="paramname"><em>stereoUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToMol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector with all <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects for the molecule. This function is used by <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> with the <code>addToMol</code> parameter is set to true. There is no algorithm used here, all specified flags will be set to false.</p>
<p>This function is also used for symmetry analysis to handle cases where there are two atoms in the same symmetry class that don't have the same stereochemistry. In this situation, the <code>addToMol</code> parameter is set to false and the returned objects will need to be deleted explicitly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">stereoUnits</td><td>The stereogenic units. </td></tr>
    <tr><td class="paramname">addToMol</td><td>If true, the <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects will be added to the molecule using <a class="el" href="classOpenBabel_1_1OBBase.shtml#adb6b0ec89bfea783825b3b466e4dbc00" title="Adds a data object; does nothing if d==NULL.">OBBase::SetData()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D</a> <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e1ba3a4ac33b0c6404b0d960cc53d00"></a><!-- doxytag: member="OpenBabel::CisTransFrom3D" ref="ga7e1ba3a4ac33b0c6404b0d960cc53d00" args="(OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;OBCisTransStereo*&gt; OpenBabel::CisTransFrom3D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereoUnitSet &amp;&#160;</td>
          <td class="paramname"><em>stereoUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToMol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector with all <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects for the molecule. This function is used by <a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D()</a> with the <code>addToMol</code> parameter is set to true.</p>
<p>The algorithm to convert the 3D coordinates to <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects considers the signed distance between the attached atoms and the plane through the double bond at right angles to the plane of the attached atoms. Bonds on the same side (cis) will share the same sign for the signed distance.</p>
<p>Missing atom coordinates (<a class="el" href="structOpenBabel_1_1OBStereo.shtml#aba01db17f4a2bfbc3db60dc172972a25a02b1798105615b9c057d777fd19f1015" title="Implicit Ref (i.e. hydrogen, N lone pair, ...).">OBStereo::ImplicitRef</a>) and their bond vectors will be computed if needed.</p>
<div class="fragment"><pre class="fragment">
         0      3     Get signed distance of 0 and 2 to the plane
          \    /      that goes through the double bond and is at
           C==C       right angles to the stereo bonds.
          /    \
         1      2     If the two signed distances have the same sign
                      then they are cis; if not, then trans.
   </pre></div><p>This function is also used for symmetry analysis to handle cases where there are two atoms in the same symmetry class that don't have the same stereochemistry. In this situation, the <code>addToMol</code> parameter is set to false and the returned objects will need to be deleted explicitly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">stereoUnits</td><td>The stereogenic units. </td></tr>
    <tr><td class="paramname">addToMol</td><td>If true, the <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects will be added to the molecule using <a class="el" href="classOpenBabel_1_1OBBase.shtml#adb6b0ec89bfea783825b3b466e4dbc00" title="Adds a data object; does nothing if d==NULL.">OBBase::SetData()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#gaebcf38fd76c5d76fffbae808b8571f9b">StereoFrom3D</a> <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>, and <a class="el" href="classOpenBabel_1_1OBBuilder.shtml#a6898b04c792072e4ace54885e9ff7b10">OBBuilder::CorrectStereoBonds()</a>.</p>

</div>
</div>
<a class="anchor" id="ga98528c3002ed718695ccfaf031ca3f04"></a><!-- doxytag: member="OpenBabel::CisTransFrom2D" ref="ga98528c3002ed718695ccfaf031ca3f04" args="(OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, const std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; *updown=NULL, bool addToMol=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;OBCisTransStereo*&gt; OpenBabel::CisTransFrom2D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereoUnitSet &amp;&#160;</td>
          <td class="paramname"><em>stereoUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; *&#160;</td>
          <td class="paramname"><em>updown</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToMol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector with all <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects for the molecule. This function is used by <a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D()</a> with the <code>addToMol</code> parameter is set to true.</p>
<p>This function is also used for symmetry analysis to handle cases where there are two atoms in the same symmetry class that don't have the same stereochemistry. In this situation, the <code>addToMol</code> parameter is set to false and the returned objects will need to be deleted explicitly.</p>
<p>The algorithm for converting the 2D coordinates uses the same triangle sign as <a class="el" href="group__stereo.shtml#gab85c5ef4c9416ee7af02b21658fe9de2">TetrahedralFrom2D()</a>. Depending on sign of 2 triangles, the right <a class="el" href="structOpenBabel_1_1OBStereo.shtml#a55b506070847a13554f8b879c1bfb37c">OBStereo::Shape</a> is selected. </p>
<div class="fragment"><pre class="fragment">
      0      3
       \    /        2 triangles: 0-1-b &amp; 2-3-a
        a==b    --&gt;  same sign: U
       /    \        opposite sign: Z
      1      2
   </pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">stereoUnits</td><td>The stereogenic units. </td></tr>
    <tr><td class="paramname">updown</td><td>A map of <a class="el" href="structOpenBabel_1_1OBStereo.shtml#a90087c9021331c97c28e9a8329f41e97">OBStereo::BondDirection</a> for cis/trans bonds </td></tr>
    <tr><td class="paramname">addToMol</td><td>If true, the <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects will be added to the molecule using <a class="el" href="classOpenBabel_1_1OBBase.shtml#adb6b0ec89bfea783825b3b466e4dbc00" title="Adds a data object; does nothing if d==NULL.">OBBase::SetData()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#ga305c9600a3a336da16683baa395e20f4">StereoFrom2D</a> <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>.</p>

</div>
</div>
<a class="anchor" id="ga182a53150e1793ac1ec14958afb05f17"></a><!-- doxytag: member="OpenBabel::TetStereoToWedgeHash" ref="ga182a53150e1793ac1ec14958afb05f17" args="(OBMol &amp;mol, std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; &amp;updown, std::map&lt; OBBond *, OBStereo::Ref &gt; &amp;from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenBabel::TetStereoToWedgeHash </td>
          <td>(</td>
          <td class="paramtype">OBMol &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; OBBond *, enum OBStereo::BondDirection &gt; &amp;&#160;</td>
          <td class="paramname"><em>updown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; OBBond *, OBStereo::Ref &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a molecule's <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> objects to a series of hash or wedge bonds. Note that the molecule itself is not modified; the result is returned in the maps <code>updown</code> and <code>from</code>, which indicate the origin and direction of each hash or wedge bond.</p>
<p>When converting, the following guidelines are followed when trying to find the best candidate bond to set up/down for each <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml" title="Class for handling and storing tetrahedral atom stereochemistry.">OBTetrahedralStereo</a> object:</p>
<ol type="1">
<li>Should not already be set</li>
<li>Should not be connected to a 2nd tet center (this is acceptable in theory as the wedge is only at one end, but in practice it may cause confusion and thus we avoid it)</li>
<li>Preferably is not in a cycle</li>
<li>Preferably is a terminal H</li>
</ol>
<p>If no bond can be found that matches rules 1 and 2 (and in theory this is possible) then an error message is logged and the function returns false. (If you find an example where this occurs, please file a bug.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">updown</td><td>A map of <a class="el" href="structOpenBabel_1_1OBStereo.shtml#a90087c9021331c97c28e9a8329f41e97">OBStereo::BondDirection</a> for each hash/wedge bond </td></tr>
    <tr><td class="paramname">from</td><td>A map of <a class="el" href="structOpenBabel_1_1OBStereo.shtml#aff913cc7d694153b33e2b3ac168a6350">OBStereo::Ref</a> indicating the origin of each hash/wedge bond </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True or False depending on whether the conversion was successful </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBDepict.shtml#a9ef29e99771a1932b2c28b34533a3e96">OBDepict::DrawMolecule()</a>.</p>

</div>
</div>
<a class="anchor" id="ga63e739a42d88ac64ed77c07d73866a45"></a><!-- doxytag: member="OpenBabel::GetUnspecifiedCisTrans" ref="ga63e739a42d88ac64ed77c07d73866a45" args="(OBMol &amp;mol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;OBBond*&gt; OpenBabel::GetUnspecifiedCisTrans </td>
          <td>(</td>
          <td class="paramtype">OBMol &amp;&#160;</td>
          <td class="paramname"><em>mol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set of double bonds corresponding to the <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects for which the stereochemistry is undefined.</p>
<p>Note that this functions just iterates over the existing <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects - it does not try to identify new ones.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set of bonds with unspecified cis/trans stereochemistry </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b44683d071146220a97390283944f70"></a><!-- doxytag: member="OpenBabel::StereoRefToImplicit" ref="ga9b44683d071146220a97390283944f70" args="(OBMol &amp;mol, OBStereo::Ref atomId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenBabel::StereoRefToImplicit </td>
          <td>(</td>
          <td class="paramtype">OBMol &amp;&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBStereo::Ref&#160;</td>
          <td class="paramname"><em>atomId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert any reference to <code>atomId</code> in a stereo object to an <a class="el" href="structOpenBabel_1_1OBStereo.shtml#aba01db17f4a2bfbc3db60dc172972a25a02b1798105615b9c057d777fd19f1015" title="Implicit Ref (i.e. hydrogen, N lone pair, ...).">OBStereo::ImplicitRef</a>. This function is called from <a class="el" href="classOpenBabel_1_1OBMol.shtml#a4e2ddc39752d20fabcda1afc1cc4e8e4">OBMol::DeleteHydrogens()</a> (via <a class="el" href="classOpenBabel_1_1OBMol.shtml#a925b41d42ddf14c12b675d32bdf5e948">OBMol::DeleteHydrogen()</a>) to remove any explicit references to a hydrogen atom that has been deleted. However, the code is not specific to hydrogen atoms and could be used for other atoms.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule </td></tr>
    <tr><td class="paramname">atomId</td><td>The Id of the atom to be converted to an <a class="el" href="structOpenBabel_1_1OBStereo.shtml#aba01db17f4a2bfbc3db60dc172972a25a02b1798105615b9c057d777fd19f1015" title="Implicit Ref (i.e. hydrogen, N lone pair, ...).">OBStereo::ImplicitRef</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="classOpenBabel_1_1OBMol.shtml#a925b41d42ddf14c12b675d32bdf5e948">OBMol::DeleteHydrogen()</a>.</p>

</div>
</div>
<a class="anchor" id="gac74fff254a639ede4d92a59fa44318a6"></a><!-- doxytag: member="OpenBabel::CisTransFrom0D" ref="gac74fff254a639ede4d92a59fa44318a6" args="(OBMol *mol, const OBStereoUnitSet &amp;stereoUnits, bool addToMol=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;OBCisTransStereo*&gt; OpenBabel::CisTransFrom0D </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereoUnitSet &amp;&#160;</td>
          <td class="paramname"><em>stereoUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToMol</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector with all <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects for the molecule. This function is used by <a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D()</a> with the <code>addToMol</code> parameter is set to true. There is no algorithm used here, all specified flags will be set to false.</p>
<p>This function is also used for symmetry analysis to handle cases where there are two atoms in the same symmetry class that don't have the same stereochemistry. In this situation, the <code>addToMol</code> parameter is set to false and the returned objects will need to be deleted explicitly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mol</td><td>The molecule. </td></tr>
    <tr><td class="paramname">stereoUnits</td><td>The stereogenic units. </td></tr>
    <tr><td class="paramname">addToMol</td><td>If true, the <a class="el" href="classOpenBabel_1_1OBCisTransStereo.shtml" title="Class for handling and storing cis/trans stereochemistry.">OBCisTransStereo</a> objects will be added to the molecule using <a class="el" href="classOpenBabel_1_1OBBase.shtml#adb6b0ec89bfea783825b3b466e4dbc00" title="Adds a data object; does nothing if d==NULL.">OBBase::SetData()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__stereo.shtml#ga419e494a34740f1f8003acabfa30a95b">StereoFrom0D</a> <a class="el" href="group__stereo.shtml#gaebf264394d502844b99b1dbe031ea185">FindStereogenicUnits</a> </dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>version 2.3 </dd></dl>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>.</p>

</div>
</div>
<a class="anchor" id="gaebf264394d502844b99b1dbe031ea185"></a><!-- doxytag: member="OpenBabel::FindStereogenicUnits" ref="gaebf264394d502844b99b1dbe031ea185" args="(OBMol *mol, const std::vector&lt; unsigned int &gt; &amp;symClasses)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OBStereoUnitSet OpenBabel::FindStereogenicUnits </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>symClasses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the stereogenic units in a molecule using a set of rules.<sup>1</sup></p>
<p>The potential stereocenters are identified first. A potential tetrahedral stereogenic atom is any atom meeting the following criteria:</p>
<ul>
<li>sp3 hybridization</li>
<li>at least 3 "heavy" neighbors</li>
</ul>
<p>Nitrogen is treated as a special case since the barrier of inversion is low in many cases making the atom non-stereogenic. Only bridge-head nitrogen atoms (i.e. nitrogen has 3 neighbors in rings) will be considered stereogenic.</p>
<p>Potential stereogenic double bonds are identified using another set of simple criteria:</p>
<ul>
<li>must be a double bond</li>
<li>must not be in a ring</li>
<li>both begin and end atom should have at least one single bond</li>
</ul>
<p>True stereocenters (i.e. stereocenters with topologically different ligands) are identified first. For tetrahedral stereocenters, true stereocenters will have 4 different neighbor atom symmetry classes and this can be expressed using T1234 to classify these stereocenters. For stereogenic bonds, a similar classification C12 can be used but both begin and end atom have their own classification and the bond is only a true stereocenter if both atoms are C12.</p>
<p>Para stereocenters are all stereocenters where there are at least two equivalent neighbor atom symmetry classes. These are T1123, T1112, T1111 and T1122 for tetrahedral stereocenters and C11 for double bonds. To determine which of the remaining potential stereocenters really are stereocenters, a set of rules is used.<sup>1</sup></p>
<p>Rule 1 is applied recusively:</p>
<p>All rings are merged "mergedRings". A merged ring is simply a fragment consisting of all atoms of a ring system (bridged, spiro, adjacent, ...). If two rings in the SSSR set share an atom, they are merged.</p>
<p>Each merged must at least have two para-stereocenters (or 1 true + 1 para) in order for the para-stereocenter to be valid. This is repeated until no new stereocenters are identified.</p>
<p>rule 1a for double bonds:</p>
<ul>
<li>bond atom in ring has two identical symmetry classes for it's neighbor atoms (-&gt; para)</li>
<li>other bond atom:<ul>
<li>has two different symmetry classes for it's neighbours -&gt; new stereocenter</li>
<li>has two identical symmetry classes, but the ligand contains at least 1 true or para stereocenter -&gt; new stereocenter</li>
</ul>
</li>
</ul>
<p>rule 1b for tetracoord atoms:</p>
<ul>
<li>at least two neighbour symmetry classes are the same (-&gt; para)</li>
<li>other pair:<ul>
<li>has two different symmetry classes for it's neighbours -&gt; new stereocenter</li>
<li>has two identical symmetry classes, but the ligand contains at least 1 true or para stereocenter -&gt; new stereocenter</li>
</ul>
</li>
</ul>
<p>Rules 2 and 3 are applied sequential (i.e. only once).</p>
<p>Rule 2a for tetracoordinate carbon:</p>
<ul>
<li>1 or 2 pair identical ligands</li>
<li>each ligand contains at least 1 true-stereocenter or 2 para-stereocenters (from rule 1)</li>
</ul>
<p>Rule 2b for tetracoordinate carbon:</p>
<ul>
<li>3 or 4 identical ligands with at least<ul>
<li>2 true-stereocenters</li>
<li>2 separate assemblies of para-stereocenters (from rule 1)</li>
</ul>
</li>
</ul>
<p>Rule 3 for double bonds:</p>
<ul>
<li>1 or 2 pair identical ligands (on begin and end atom)</li>
<li>each pair contains at least 1 true-stereocenter or 2 para-stereocenters (from rule 1)</li>
</ul>
<div class="fragment"><pre class="fragment">
     Reference:
     [1] M. Razinger, K. Balasubramanian, M. Perdih, M. E. Munk, Stereoisomer
     Generation in Computer-Enhanced Structure Elucidation, J. Chem. Inf.
     Comput. Sci. 1993, 33, 812-825
     </pre></div> 
<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f62e73467d2059ad28d544633634862"></a><!-- doxytag: member="OpenBabel::FindStereogenicUnits" ref="ga0f62e73467d2059ad28d544633634862" args="(OBMol *mol, const std::vector&lt; unsigned int &gt; &amp;symClasses, const Automorphisms &amp;automorphisms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OBStereoUnitSet OpenBabel::FindStereogenicUnits </td>
          <td>(</td>
          <td class="paramtype">OBMol *&#160;</td>
          <td class="paramname"><em>mol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>symClasses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Automorphisms &amp;&#160;</td>
          <td class="paramname"><em>automorphisms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the stereogenic units in a molecule making use of the automorphisms. </p>
<p>The potential stereocenters are identified first. A potential tetrahedral stereogenic atom is any atom meeting the following criteria:</p>
<ul>
<li>sp3 hybridization</li>
<li>at least 3 "heavy" neighbors</li>
</ul>
<p>Nitrogen is treated as a special case since the barrier of inversion is low in many cases making the atom non-stereogenic. Only bridge-head nitrogen atoms (i.e. nitrogen has 3 neighbors in rings) will be considered stereogenic.</p>
<p>Potential stereogenic double bonds are identified using another set of simple criteria:</p>
<ul>
<li>must be a double bond</li>
<li>must not be in a ring</li>
<li>both begin and end atom should have at least one single bond</li>
</ul>
<p>Once the potential stereocenters are found, the automorphisms are the key to identifying real stereogenic units. Automorphisms can be seen as permutations that permutate a graph back to the same graph. Such a permutation can only exchange atoms with the same symmetry class and it follows that the use of automorphisms takes symmetry into account. The definitions below use a concept where the automorphisms cause inversions of configuration to potential stereocenters. Such an inversion occurs whenever an automorphism exchanges two equivalent (i.e. with the same symmetry class) neighbor atoms attached to the potential stereogenic unit.</p>
<dl class="user"><dt><b>Definition for tetrahedral stereocenters:</b></dt><dd>A potential stereocenter really is a stereocenter if there exists no automorphic permutation causing an inversion of the configuration of only the potential stereogenic unit under consideration. If there exists at least one automorphic permutation causing an inversion of the configuration, then the potential stereogenic center can be a stereogenic center if the number of topologically equivalent neighbors (ligands) of the potential stereogenic center is less than or equal to the number of different configurations of these ligands.<sup>1</sup></dd></dl>
<p>The actual number of configurations needed for the ligands depends on the classification (i.e. T1234, T1123, ...) of the stereo center. These classes reflect the symmetry classes of the neighbor atoms of the center.</p>
<ul>
<li>T1123: 1 true stereocenter OR 2 para stereocenters</li>
<li>T1122: 1 true stereocenter OR 2 para stereocenters (for both)</li>
<li>T1112: 2 true stereocenters OR 2 para stereocenter assemblies</li>
<li>T1111: 2 true stereocenters OR 2 para stereocenter assemblies</li>
</ul>
<dl class="user"><dt><b>Definition for double bond stereocenters:</b></dt><dd>A potential stereogenic double bond really is a stereogenic bond if there exists no automorphic permutation causing an inversion of the configuration of only the potential stereogenic unit under consideration. The bond can still be a stereogenic bond if there exists such an automorphism when the number of configurations of the pair of topologically equivalent geminal ligands, which are exchanged by the automorphism, is greater than or equal to two (i.e. the number of topologically equivalent geminal ligands.<sup>1</sup></dd></dl>
<p>For stereogenic bonds, there is only one case but both begin and end atom have to be checked.</p>
<ul>
<li>C11: 1 true stereocenter OR 1 para stereocenter</li>
</ul>
<p>These criteria are analogous to the rules from the Razinger paper on stereoisomer generation. Since the existance of stereocenters can depend on the existance of other stereocenters (in the ligands), the stereocenters are found by iterating until no new stereocenters are found.</p>
<div class="fragment"><pre class="fragment">
     Reference:
     [1] M. Perdih, M. Razinger, Stereochemistry and Sequence Rules:
     A Proposal for Modification of Cahn-Ingold-Prelog System,
     Tetrahedron: Asymmetry, 1994, Vol. 5, No. 5, 835-861
     </pre></div> 
</div>
</div>
<a class="anchor" id="ga30c6cc4c63f918bad5ed504e0e53edc6"></a><!-- doxytag: member="std::operator&lt;&lt;" ref="ga30c6cc4c63f918bad5ed504e0e53edc6" args="(ostream &amp;out, const OpenBabel::OBTetrahedralStereo &amp;ts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; std::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenBabel_1_1OBTetrahedralStereo.shtml">OpenBabel::OBTetrahedralStereo</a> &amp;&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> OBTetrahedralStereo::Config cfg;
 cfg.center = 0;
 cfg.towards = 4;
 cfg.refs = OBStereo::MakeRefs(1, 2, 3);
 cfg.winding = OBStereo::AntiClockwise;
 cfg.view = OBStereo::ViewTowards;

 OBTetrahedralStereo ts(mol);
 ts.SetConfig(cfg)

 cout &lt;&lt; <span class="stringliteral">&quot;ts = &quot;</span> &lt;&lt; ts &lt;&lt; endl;

 <span class="comment">// output</span>
 OBTetrahedralStereo(center = 0, viewTowards = 4, refs = 1 2 3, anti-clockwise)
</pre></div> 
</div>
</div>
<a class="anchor" id="gaa6dbf885c726a181852e742bb0b9a65d"></a><!-- doxytag: member="std::operator&lt;&lt;" ref="gaa6dbf885c726a181852e742bb0b9a65d" args="(ostream &amp;out, const OpenBabel::OBTetrahedralStereo::Config &amp;cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; std::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOpenBabel_1_1OBTetrahedralStereo_1_1Config.shtml">OpenBabel::OBTetrahedralStereo::Config</a> &amp;&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> OBTetrahedralStereo::Config cfg;
 cfg.center = 0;
 cfg.towards = 4;
 cfg.refs = OBStereo::MakeRefs(1, 2, 3);
 cfg.winding = OBStereo::AntiClockwise;
 cfg.view = OBStereo::ViewTowards;

 cout &lt;&lt; <span class="stringliteral">&quot;cfg = &quot;</span> &lt;&lt; cfg &lt;&lt; endl;

 <span class="comment">// output</span>
 OBTetrahedralStereo::Config(center = 0, viewTowards = 4, refs = 1 2 3, anti-clockwise)
</pre></div> 
</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- end content -->

<!--#include file="footer.html" -->

<div id="footer">
<hr size="1">
<img src="http://openbabel.org/babel256.png" width="136" height="127" alt="" style="float: left;" />
<p>This file is part of the documentation for <a href="http://openbabel.org/wiki/">Open Babel</a>, version 2.3.</p>
<div class="bottom">
Documentation copyright &copy; 1998-2007, the <a href="http://openbabel.org/wiki/THANKS">Open Babel Developers</a>.<br>
Open Babel is hosted by: <a href="http://sourceforge.net">
<img src="http://sourceforge.net/sflogo.php?group_id=40728" 
width="88" height="31" border="0" alt="SourceForge Logo"></a><br>
Generated on Thu Oct 13 2011 16:08:08 by&nbsp;<a href="http://www.doxygen.org/"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.5.1.
</div>

</body>
</html>
