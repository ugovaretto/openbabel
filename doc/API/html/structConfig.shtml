<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Open Babel: Config Struct Reference</title>
<link href="/site.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="search/search.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<!--#include file="header.html" -->
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.shtml"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.shtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.shtml"><span>Modules</span></a></li>
      <li><a href="namespaces.shtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.shtml"><span>Classes</span></a></li>
      <li><a href="files.shtml"><span>Files</span></a></li>
      <li><a href="examples.shtml"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.shtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.shtml"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.shtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.shtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Config Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Config" -->
<p><code>#include &lt;<a class="el" href="cistrans_8h_source.shtml">cistrans.h</a>&gt;</code></p>

<p><a href="structConfig-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a539a941e29cde8d13e413c515d9801cd">Config</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#acf25320b7c10321198305519ad78680c">Config</a> (unsigned long _begin, unsigned long _end, const OBStereo::Refs &amp;_refs, OBStereo::Shape _shape=OBStereo::ShapeU)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a929278c4f025d8340ab65d86696386e4">operator==</a> (const <a class="el" href="structConfig.shtml">Config</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3f058aa3902997deaaefc72fe0355477">operator!=</a> (const <a class="el" href="structConfig.shtml">Config</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a539a941e29cde8d13e413c515d9801cd">Config</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3932e85a5b2cc866ab349584485a5b1c">Config</a> (unsigned long _center, const OBStereo::Refs &amp;_refs, OBStereo::Shape _shape=OBStereo::ShapeU)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a929278c4f025d8340ab65d86696386e4">operator==</a> (const <a class="el" href="structConfig.shtml">Config</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3f058aa3902997deaaefc72fe0355477">operator!=</a> (const <a class="el" href="structConfig.shtml">Config</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a539a941e29cde8d13e413c515d9801cd">Config</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a1410755ad2d5b4c0f3a6b9f0c9f04789">Config</a> (unsigned long _center, unsigned long from_or_towards, const OBStereo::Refs &amp;_refs, OBStereo::Winding _winding=OBStereo::Clockwise, OBStereo::View _view=OBStereo::ViewFrom)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a929278c4f025d8340ab65d86696386e4">operator==</a> (const <a class="el" href="structConfig.shtml">Config</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3f058aa3902997deaaefc72fe0355477">operator!=</a> (const <a class="el" href="structConfig.shtml">Config</a> &amp;other) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3237fb5e8bbcbececce85cb5d85195b6">from</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#aa88a28c7375e3d579bb0c28ef8a1cb57">towards</a></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data members defining stereochemistry.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a43ec7ce807e545cea2247cd68bc7b7e9">begin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#ac31c5196f50f192d5db1d85180b05aaf">end</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OBStereo::Refs&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3e3f2a8fefc9f694040bbb8685cb61e1">refs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OBStereo::Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a77f6538bd30b4203bd2b2bba33c28c85">shape</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#ad137707f900f599f5f403d9639e2aec3">specified</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a822b3ed2ceea391277903da02d1fd0a2">center</a></td></tr>
<tr><td class="memItemLeft" >union {</td></tr>
<tr><td class="memItemLeft" >&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<a class="el" href="structConfig.shtml#a3237fb5e8bbcbececce85cb5d85195b6">from</a></td></tr>
<tr><td class="memItemLeft" >&#160;&#160;&#160;unsigned long&#160;&#160;&#160;<a class="el" href="structConfig.shtml#aa88a28c7375e3d579bb0c28ef8a1cb57">towards</a></td></tr>
<tr><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OBStereo::Winding&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a4ea32436f7428861ff7d4543570f4451">winding</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OBStereo::View&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConfig.shtml#a3a41b22504236f1bc6908201a3289184">view</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The config struct represents the stereochemistry in a well defined way. For cis/trans stereo bonds, the following data members define the spacial arrengement of the atoms.</p>
<ul>
<li>OBStereo::Ref <code>begin:</code> The begin atom for the double bond.</li>
<li>OBStereo::Ref <code>end:</code> The end atom for the double bond.</li>
<li>OBStereo::Refs <code>refs:</code> The 4 atoms connected to the double bond.</li>
<li>OBStereo::Shape <code>shape:</code> The shape formed by the <code>refs</code> by connecting them in the same order as they occur in <code>refs</code>.</li>
</ul>
<div align="center">
<img src="cistrans.png" alt="cistrans.png"/>
</div>
 <div align="center">
<img src="SPshapes.png" alt="SPshapes.png"/>
</div>
<p>Only <code>begin</code> and <code>end</code> are specific for OBCisTransStereo::Config. The other data members occur in all OBTetraPlanarStereo derived classes.</p>
<p>The config struct represents the stereochemistry in a well defined way. For squareplanar stereocenters, the following data members define the spacial arrengement of the atoms.</p>
<ul>
<li>OBStereo::Ref <code>center:</code> The central atom.</li>
<li>OBStereo::Refs <code>refs:</code> The 4 atoms connected to the double bond.</li>
<li>OBStereo::Shape <code>shape:</code> The shape formed by the <code>refs</code> by connecting them in the same order as they occur in <code>refs</code>.</li>
</ul>
<div align="center">
<img src="squareplanar.png" alt="squareplanar.png"/>
</div>
 <div align="center">
<img src="SPshapes.png" alt="SPshapes.png"/>
</div>
<p>Only <code>center</code> are specific for OBSquarePlanarStereo::Config. The other data members occur in all OBTetraPlanarStereo derived classes.</p>
<p>The config struct represents the stereochemistry in a well defined way. For tetrahedral stereo centers, the following data members define the special orientation of the atoms:</p>
<ul>
<li>OBStereo::Ref <code>center:</code> Atom id of the stereogenic center atom.</li>
<li>OBStereo::Ref <code>from/towards</code>: Atom id (or OBStereo::ImplicitRef) for the atom to view from/towards.</li>
<li>OBStereo::Refs <code>refs:</code> The three remaining atom ids (may also contain one OBStereo::NoRef element if from/towards is set to a real atom id).</li>
<li>OBStereo::View <code>view:</code> Specify the viewing from or towards the atom with <code>from/towards</code> id.</li>
<li>OBStereo::Winding <code>winding:</code> Clockwise or AntiClockwise (order in the Refs <code>refs</code> list)</li>
</ul>
<div align="center">
<img src="tetrahedral.png" alt="tetrahedral.png"/>
</div>
<p>Only <code>center</code> is specific for OBTetrahedralStereo::Config. The other data members occur in all OBTetraNonPlanarStereo derived classes. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a539a941e29cde8d13e413c515d9801cd"></a><!-- doxytag: member="Config::Config" ref="a539a941e29cde8d13e413c515d9801cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConfig.shtml">Config</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. Initializes <code>begin</code> and <code>end</code> to OBStereo::NoRef and <code>shape</code> to OBStereo::ShapeU. </p>

</div>
</div>
<a class="anchor" id="acf25320b7c10321198305519ad78680c"></a><!-- doxytag: member="Config::Config" ref="acf25320b7c10321198305519ad78680c" args="(unsigned long _begin, unsigned long _end, const OBStereo::Refs &amp;_refs, OBStereo::Shape _shape=OBStereo::ShapeU)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConfig.shtml">Config</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"> <em>_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"> <em>_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereo::Refs &amp;&#160;</td>
          <td class="paramname"> <em>_refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBStereo::Shape&#160;</td>
          <td class="paramname"> <em>_shape</em> = <code>OBStereo::ShapeU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor with all parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_begin</td><td>The double bond begin atom id. </td></tr>
    <tr><td class="paramname">_end</td><td>The double bond end atom id. </td></tr>
    <tr><td class="paramname">_refs</td><td>The 4 reference ids. </td></tr>
    <tr><td class="paramname">_shape</td><td>The shape for the 4 reference ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a539a941e29cde8d13e413c515d9801cd"></a><!-- doxytag: member="Config::Config" ref="a539a941e29cde8d13e413c515d9801cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConfig.shtml">Config</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. Initializes <code>center</code> to OBStereo::NoRef and <code>shape</code> to OBStereo::ShapeU. </p>

</div>
</div>
<a class="anchor" id="a3932e85a5b2cc866ab349584485a5b1c"></a><!-- doxytag: member="Config::Config" ref="a3932e85a5b2cc866ab349584485a5b1c" args="(unsigned long _center, const OBStereo::Refs &amp;_refs, OBStereo::Shape _shape=OBStereo::ShapeU)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConfig.shtml">Config</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"> <em>_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereo::Refs &amp;&#160;</td>
          <td class="paramname"> <em>_refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBStereo::Shape&#160;</td>
          <td class="paramname"> <em>_shape</em> = <code>OBStereo::ShapeU</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor with all parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_center</td><td>The atom id for the central atom. </td></tr>
    <tr><td class="paramname">_refs</td><td>The 4 reference ids. </td></tr>
    <tr><td class="paramname">_shape</td><td>The shape for the 4 reference ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a539a941e29cde8d13e413c515d9801cd"></a><!-- doxytag: member="Config::Config" ref="a539a941e29cde8d13e413c515d9801cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConfig.shtml">Config</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. Initializes the <code>from/torards</code> and <code>center</code> to OBStereo::NoRef, the <code>winding</code> to OBStereo::Clockwise and <code>view</code> to OBStereo::ViewFrom. </p>

</div>
</div>
<a class="anchor" id="a1410755ad2d5b4c0f3a6b9f0c9f04789"></a><!-- doxytag: member="Config::Config" ref="a1410755ad2d5b4c0f3a6b9f0c9f04789" args="(unsigned long _center, unsigned long from_or_towards, const OBStereo::Refs &amp;_refs, OBStereo::Winding _winding=OBStereo::Clockwise, OBStereo::View _view=OBStereo::ViewFrom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structConfig.shtml">Config</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"> <em>_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"> <em>from_or_towards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OBStereo::Refs &amp;&#160;</td>
          <td class="paramname"> <em>_refs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBStereo::Winding&#160;</td>
          <td class="paramname"> <em>_winding</em> = <code>OBStereo::Clockwise</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OBStereo::View&#160;</td>
          <td class="paramname"> <em>_view</em> = <code>OBStereo::ViewFrom</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor with all parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">_center</td><td>The center (chiral) atom id. </td></tr>
    <tr><td class="paramname">from_or_towards</td><td>The atom id from which to view or view towards (see <code>view</code>). </td></tr>
    <tr><td class="paramname">_refs</td><td>The 3 reference ids. </td></tr>
    <tr><td class="paramname">_winding</td><td>The winding for the 3 ids in <code>_refs</code>. </td></tr>
    <tr><td class="paramname">_view</td><td>Specify viewing from or towards the atom with <code>from_or_towards</code> id. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a929278c4f025d8340ab65d86696386e4"></a><!-- doxytag: member="Config::operator==" ref="a929278c4f025d8340ab65d86696386e4" args="(const Config &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structConfig.shtml">Config</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Equal to operator. Comparing OBCisTransStereo::Config structs is done using the information stored in the struct's data members (i.e. begin, end, refs and shape).</p>
<p>There are a number of cases resuling in false being returned:</p>
<ul>
<li><code>begin</code> and <code>end</code> don't match (is checked using the 2 combinations)</li>
<li>One of the Refs lists does not contain 4 elements.</li>
<li>2 or more OBStereo::ImplicitRef values in a single <a class="el" href="structConfig.shtml">Config</a> struct</li>
<li>(The two <code>refs</code> don't share a single common element)</li>
</ul>
<p>In the simplest case where both <code>refs</code> contain exactly the same elements (OBStereo::ContainsSameRefs()), coould include OBStereo::ImplicitRef), both <a class="el" href="structConfig.shtml">Config</a> struct are normalized to OBStereo::ShapeU starting with the same element. After this normalization, there are two possible orientations to overlay the shape on the double bond. From the illustration below, it can be seen only <code>refs</code>[2] has to be checked in order to conclude both <a class="el" href="structConfig.shtml">Config</a> structs have the same stereochemistry.</p>
<div class="fragment"><pre class="fragment">
         1      4    1      4    1------4
          \    /     |      |           |
           C==C      |      |           |
          /    \     |      |           |
         2      3    2------3    2------3

                     1 2 3 4     1 2 3 4
                     |   |       |   |      &lt;- in any case, refs[0] &amp; refs[2] remain unchanged
                     1 2 3 4     1 4 3 2
        </pre></div><p>When comparing a <a class="el" href="structConfig.shtml">Config</a> struct with explicit hydrogen(s) to one with implicit hydrogen(s), both <code>refs</code> are also normalized to OBStereo::ShapeU starting with the same common element. This shared element cannot be OBStereo::ImplicitRef. Depending on the position of the OBStereo::ImplicitRef element(s) in the <code>refs</code>, 3 cases are possible:</p>
<div class="fragment"><pre class="fragment">

         refs[2] != OBStereo::ImplicitId:

           (analog to the case above where they contained the same elements )

           1 2 3 4
           |   |      &lt;- refs[0] &amp; refs[2] remain unchanged
           1 H 3 H

         else:

           1 2 3 4
           |     |    &lt;- refs[0] &amp; refs[3] remain unchanged
           1 H H 4

           1 2 3 4
           | |        &lt;- refs[0] &amp; refs[1] remain unchanged
           1 2 H H
        </pre></div><p>In each case, the orientation of the U shape is also defined since there can be only one OBStereo::ImplicitRef for each side of the double bond.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if both <a class="el" href="structConfig.shtml">Config</a> structs represent the stereochemistry. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f058aa3902997deaaefc72fe0355477"></a><!-- doxytag: member="Config::operator!=" ref="a3f058aa3902997deaaefc72fe0355477" args="(const Config &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structConfig.shtml">Config</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Not equal to operator. This is the inverse of the Equal to operator==.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the two <a class="el" href="structConfig.shtml">Config</a> structs represent a different stereochemistry. </dd></dl>

</div>
</div>
<a class="anchor" id="a929278c4f025d8340ab65d86696386e4"></a><!-- doxytag: member="Config::operator==" ref="a929278c4f025d8340ab65d86696386e4" args="(const Config &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structConfig.shtml">Config</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Equal to operator. Comparing OBSquarePlanarStereo::Config structs is done using the information stored in the struct's data members (i.e. center, refs and shape).</p>
<p>There are a number of cases resuling in false being returned:</p>
<ul>
<li><code>center</code> atom ids don't match</li>
<li>One of the Refs lists does not contain 4 elements.</li>
<li>2 or more OBStereo::ImplicitRef values in a single <a class="el" href="structConfig.shtml">Config</a> struct</li>
<li>(The two <code>refs</code> don't share a single common element)</li>
</ul>
<p>In the simplest case where both <code>refs</code> contain exactly the same elements (OBStereo::ContainsSameRefs()), coould include OBStereo::ImplicitRef), both <a class="el" href="structConfig.shtml">Config</a> struct are normalized to OBStereo::ShapeU starting with the same element. After this normalization, there are two possible orientations to overlay the shape on the double bond. From the illustration below, it can be seen only <code>refs</code>[2] has to be checked in order to conclude both <a class="el" href="structConfig.shtml">Config</a> structs have the same stereochemistry.</p>
<div class="fragment"><pre class="fragment">
         1   4    1      4    1------4
          \ /     |      |           |
           C      |      |           |
          / \     |      |           |
         2   3    2------3    2------3

                  1 2 3 4     1 2 3 4
                  |   |       |   |      &lt;- in any case, refs[0] &amp; refs[2] remain unchanged
                  1 2 3 4     1 4 3 2
        </pre></div><p>When comparing a <a class="el" href="structConfig.shtml">Config</a> struct with explicit hydrogen(s) to one with implicit hydrogen(s), both <code>refs</code> are also normalized to OBStereo::ShapeU starting with the same common element. This shared element cannot be OBStereo::ImplicitRef. Depending on the position of the OBStereo::ImplicitRef element(s) in the <code>refs</code>, 3 cases are possible:</p>
<div class="fragment"><pre class="fragment">

         refs[2] != OBStereo::ImplicitId:

           (analog to the case above where they contained the same elements )

           1 2 3 4
           |   |      &lt;- refs[0] &amp; refs[2] remain unchanged
           1 H 3 H

         else:

           1 2 3 4
           |     |    &lt;- refs[0] &amp; refs[3] remain unchanged
           1 H H 4

           1 2 3 4
           | |        &lt;- refs[0] &amp; refs[1] remain unchanged
           1 2 H H
        </pre></div><p>In each case, the orientation of the U shape is also defined since there can be only one OBStereo::ImplicitRef for each side of the double bond.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if both <a class="el" href="structConfig.shtml">Config</a> structs represent the stereochemistry. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f058aa3902997deaaefc72fe0355477"></a><!-- doxytag: member="Config::operator!=" ref="a3f058aa3902997deaaefc72fe0355477" args="(const Config &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structConfig.shtml">Config</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Not equal to operator. This is the inverse of the Equal to operator==.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the two <a class="el" href="structConfig.shtml">Config</a> structs represent a different stereochemistry. </dd></dl>

</div>
</div>
<a class="anchor" id="a929278c4f025d8340ab65d86696386e4"></a><!-- doxytag: member="Config::operator==" ref="a929278c4f025d8340ab65d86696386e4" args="(const Config &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structConfig.shtml">Config</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Equal to operator. Comparing OBTetrahedralStereo::Config structs is done using the information stored in the struct's data members (i.e. <code>view</code>, <code>winding</code>, <code>from/towards</code> and <code>refs</code>).</p>
<p>There are a number of cases resuling in false being returned:</p>
<ul>
<li>The centers don't match.</li>
<li>One of the Refs lists does not contain 3 elements.</li>
<li>2 or more OBStereo::ImplicitRef values in a single <a class="el" href="structConfig.shtml">Config</a> struct</li>
</ul>
<p>When either <a class="el" href="structConfig.shtml">Config</a> struct is unspecified (i.e. the stereochemistry implied is accidental), true is returned.</p>
<p>It doesn't matter if the two <a class="el" href="structConfig.shtml">Config</a> structs use the same view, same from/towards Ref or the same winding. All needed conversions will be carried out automatically (see OBTetraNonPlanerStereo::ToConfig). These conversions ensure the spacial orientation of the 4 groups remains unchanged.</p>
<p>Another key feature is the ability to comapre <a class="el" href="structConfig.shtml">Config</a> structs regardless of implicit (OBStereo::ImplicitRef) or explicit hydrogens. This is best illustrated with some examples. In these examples the same ref has already been selected as from/towards atom and both use the same winding and view direction. We will focus on how the three remaining refs are interpreted.</p>
<div class="fragment"><pre class="fragment">
         234 == 234 // true
         2H4 == 234 // 3 is missing, must be the implicit --&gt; 234 == 234 // true
         2H4 == 243 // same as above, but now 234 == 243 // false
         234 == H34 // 2 is missing, must be implicit --&gt; 234 == 234 // true
       </pre></div><p>By comparing the second and third example above, it can be clearly seen that the value of 1 Ref can actually be ignored. It's position in the sequence (or the winding) is defined by the two explicit Ref values.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if both <a class="el" href="structConfig.shtml">Config</a> structs represent the same stereochemistry. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f058aa3902997deaaefc72fe0355477"></a><!-- doxytag: member="Config::operator!=" ref="a3f058aa3902997deaaefc72fe0355477" args="(const Config &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structConfig.shtml">Config</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Not equal to operator. This is the inverse of the Equal to operator==.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the two <a class="el" href="structConfig.shtml">Config</a> structs represent a different stereochemistry. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a43ec7ce807e545cea2247cd68bc7b7e9"></a><!-- doxytag: member="Config::begin" ref="a43ec7ce807e545cea2247cd68bc7b7e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="structConfig.shtml#a43ec7ce807e545cea2247cd68bc7b7e9">begin</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac31c5196f50f192d5db1d85180b05aaf"></a><!-- doxytag: member="Config::end" ref="ac31c5196f50f192d5db1d85180b05aaf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="structConfig.shtml#ac31c5196f50f192d5db1d85180b05aaf">end</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e3f2a8fefc9f694040bbb8685cb61e1"></a><!-- doxytag: member="Config::refs" ref="a3e3f2a8fefc9f694040bbb8685cb61e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OBStereo::Refs <a class="el" href="structConfig.shtml#a3e3f2a8fefc9f694040bbb8685cb61e1">refs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The 4 reference ids. </p>
<p>The 3 reference ids. </p>

</div>
</div>
<a class="anchor" id="a77f6538bd30b4203bd2b2bba33c28c85"></a><!-- doxytag: member="Config::shape" ref="a77f6538bd30b4203bd2b2bba33c28c85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OBStereo::Shape <a class="el" href="structConfig.shtml#a77f6538bd30b4203bd2b2bba33c28c85">shape</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The shape of the 4 reference ids. </p>

</div>
</div>
<a class="anchor" id="ad137707f900f599f5f403d9639e2aec3"></a><!-- doxytag: member="Config::specified" ref="ad137707f900f599f5f403d9639e2aec3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structConfig.shtml#ad137707f900f599f5f403d9639e2aec3">specified</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>True if the stereochemistry is specified. When false, the described special orientation is only accidental (i.e. unspecified). </p>

<p>Referenced by <a class="el" href="namespaceOpenBabel.shtml#a62d602f9ffb93ae1f37c2d3bbf010d77">OpenBabel::CanonicalLabels()</a>.</p>

</div>
</div>
<a class="anchor" id="a822b3ed2ceea391277903da02d1fd0a2"></a><!-- doxytag: member="Config::center" ref="a822b3ed2ceea391277903da02d1fd0a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="structConfig.shtml#a822b3ed2ceea391277903da02d1fd0a2">center</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3237fb5e8bbcbececce85cb5d85195b6"></a><!-- doxytag: member="Config::from" ref="a3237fb5e8bbcbececce85cb5d85195b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="structConfig.shtml#a3237fb5e8bbcbececce85cb5d85195b6">from</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa88a28c7375e3d579bb0c28ef8a1cb57"></a><!-- doxytag: member="Config::towards" ref="aa88a28c7375e3d579bb0c28ef8a1cb57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="structConfig.shtml#aa88a28c7375e3d579bb0c28ef8a1cb57">towards</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afd0d465b29aa1f032e30407f5d5b1ea2"></a><!-- doxytag: member="Config::@17" ref="afd0d465b29aa1f032e30407f5d5b1ea2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union { ... } </td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ea32436f7428861ff7d4543570f4451"></a><!-- doxytag: member="Config::winding" ref="a4ea32436f7428861ff7d4543570f4451" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OBStereo::Winding <a class="el" href="structConfig.shtml#a4ea32436f7428861ff7d4543570f4451">winding</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3a41b22504236f1bc6908201a3289184"></a><!-- doxytag: member="Config::view" ref="a3a41b22504236f1bc6908201a3289184" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OBStereo::View <a class="el" href="structConfig.shtml#a3a41b22504236f1bc6908201a3289184">view</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify viewing from or towards the atom with <code>from/towards</code> id. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="cistrans_8h_source.shtml">cistrans.h</a></li>
<li><a class="el" href="squareplanar_8h_source.shtml">squareplanar.h</a></li>
<li><a class="el" href="tetrahedral_8h_source.shtml">tetrahedral.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- end content -->

<!--#include file="footer.html" -->

<div id="footer">
<hr size="1">
<img src="http://openbabel.org/babel256.png" width="136" height="127" alt="" style="float: left;" />
<p>This file is part of the documentation for <a href="http://openbabel.org/wiki/">Open Babel</a>, version 2.3.</p>
<div class="bottom">
Documentation copyright &copy; 1998-2007, the <a href="http://openbabel.org/wiki/THANKS">Open Babel Developers</a>.<br>
Open Babel is hosted by: <a href="http://sourceforge.net">
<img src="http://sourceforge.net/sflogo.php?group_id=40728" 
width="88" height="31" border="0" alt="SourceForge Logo"></a><br>
Generated on Fri Oct 22 2010 14:36:03 by&nbsp;<a href="http://www.doxygen.org/"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.7.2.
</div>

</body>
</html>
